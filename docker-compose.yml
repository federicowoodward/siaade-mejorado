x-postgres-common: &postgres-common
  image: postgres:16-alpine
  env_file:
    - .env
  environment:
    POSTGRES_DB: ${POSTGRES_DB}
    POSTGRES_USER: ${POSTGRES_USER}
    POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    PGDATA: /var/lib/postgresql/data/pgdata
  volumes:
    - postgres_data:/var/lib/postgresql/data
  networks:
    siaade_net:
      aliases:
        - postgres
  restart: unless-stopped
  healthcheck:
    test:
      - CMD-SHELL
      - pg_isready -U "${POSTGRES_USER}" -d "${POSTGRES_DB}"
    interval: 10s
    timeout: 5s
    retries: 12
    start_period: 20s

x-api-common: &api-common
  build:
    context: ./backend
    dockerfile: Dockerfile
  env_file:
    - .env
  networks:
    - siaade_net
  restart: unless-stopped
  healthcheck:
    test:
      - CMD-SHELL
      - wget -qO- http://127.0.0.1:3000/health >/dev/null || exit 1
    interval: 30s
    timeout: 10s
    retries: 5
    start_period: 30s

x-front-build: &front-build
  context: ./front
  dockerfile: Dockerfile

x-front-common: &front-common
  build:
    <<: *front-build
    args:
      ANGULAR_CONFIGURATION: production
  env_file:
    - .env
  networks:
    - siaade_net
  restart: unless-stopped
  healthcheck:
    test:
      - CMD-SHELL
      - wget -qO- http://127.0.0.1:4000 >/dev/null || exit 1
    interval: 30s
    timeout: 10s
    retries: 5
    start_period: 30s

services:
  postgres-local:
    <<: *postgres-common
    profiles:
      - local
    ports:
      - 5432:5432

  postgres:
    <<: *postgres-common
    profiles:
      - prod

  api:
    <<: *api-common
    profiles:
      - local
    depends_on:
      postgres-local:
        condition: service_healthy
    environment:
      NODE_ENV: development
      DATABASE_URL: ${DATABASE_URL}
      DB_SSL: ${DB_SSL:-false}
      CORS_ORIGIN: ${API_CORS_ORIGIN:-http://localhost:4000}
    ports:
      - 3000:3000

  front:
    <<: *front-common
    profiles:
      - local
    build:
      <<: *front-build
      args:
        ANGULAR_CONFIGURATION: development
    depends_on:
      api:
        condition: service_started
    environment:
      NODE_ENV: development
    ports:
      - 4000:4000

  api-prod:
    <<: *api-common
    profiles:
      - prod
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      NODE_ENV: production
      DATABASE_URL: ${DATABASE_URL}
      DB_SSL: ${DB_SSL:-false}
    labels:
      - traefik.enable=true
      - "traefik.http.routers.api.rule=Host(`$${DUCKDNS_DOMAIN}`) && PathPrefix(`/api`)"
      - traefik.http.routers.api.entrypoints=websecure
      - traefik.http.routers.api.tls.certresolver=letsencrypt
      - traefik.http.routers.api.middlewares=api-strip@docker,security-headers@file,gzip-compress@file
      - traefik.http.services.api.loadbalancer.server.port=3000
      - traefik.http.middlewares.api-strip.stripprefix.prefixes=/api

  front-prod:
    <<: *front-common
    profiles:
      - prod
    depends_on:
      api-prod:
        condition: service_started
    environment:
      NODE_ENV: production
    labels:
      - traefik.enable=true
      - "traefik.http.routers.front.rule=Host(`$${DUCKDNS_DOMAIN}`)"
      - traefik.http.routers.front.entrypoints=websecure
      - traefik.http.routers.front.tls.certresolver=letsencrypt
      - traefik.http.routers.front.middlewares=security-headers@file,gzip-compress@file
      - traefik.http.services.front.loadbalancer.server.port=4000

  traefik:
    image: traefik:v2.11
    profiles:
      - prod
    env_file:
      - .env
    command:
      - --configFile=/traefik.yml
    ports:
      - 80:80
      - 443:443
    depends_on:
      api-prod:
        condition: service_started
      front-prod:
        condition: service_started
    volumes:
      - ./traefik/traefik.yml:/traefik.yml:ro
      - ./traefik/dynamic.yml:/dynamic.yml:ro
      - traefik_letsencrypt:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - siaade_net
    restart: unless-stopped
    healthcheck:
      test:
        - CMD
        - traefik
        - healthcheck
        - --ping
      interval: 30s
      timeout: 10s
      retries: 6
      start_period: 30s

  duckdns:
    image: lscr.io/linuxserver/duckdns:latest
    profiles:
      - prod
    env_file:
      - .env
    environment:
      TOKEN: ${DUCKDNS_TOKEN}
      LOG_FILE: "false"
      DUCKDNS_DOMAIN: ${DUCKDNS_DOMAIN}
    entrypoint:
      - /bin/sh
      - -c
    command: |
      export SUBDOMAINS=$${DUCKDNS_DOMAIN%%.duckdns.org} && exec /init
    networks:
      - siaade_net
    restart: unless-stopped
    healthcheck:
      test:
        - CMD-SHELL
        - curl -fsS https://www.duckdns.org >/dev/null || exit 1
      interval: 5m
      timeout: 10s
      retries: 3
      start_period: 1m

volumes:
  postgres_data:
  traefik_letsencrypt:

networks:
  siaade_net:
    driver: bridge
